---
title: Passing type-safe state setters from parent to child components
date: 2020-01-04T00:00:00+0000
description: Pass around stateful CRUD operations with confidence
---

Recently, I've been on a bit of a [crusade](https://www.tuckerblackwell.com/react-vs-context-vs-redux/) against using Redux or other state management solutions for scenarios or pieces of state that don't really require it. I'm not going to expound upon that here, though. I'd like to share the ways in which I handle CRUD (**C**reate, **R**ead, **U**pdate, **D**elete) in my apps that's void of external state management (with the help of TypeScript)

Let's get into it.

Let's set up a scenario where we have an app that has CRUD associated with various posts and, for simplicity, the state for these posts is set up in a central `App` component. This component will fetch posts from an API, set them to local state and then pass various state updaters to its children. Will get to those updaters in a moment, first let's fetch our posts.

```javascript
export interface Post {
    id: string;
    content: string;
    date: Date;
}

const App: React.FC = (): JSX.Element => {
    const [posts, setPosts] = useState<Post[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<boolean>(false);

    useEffect(() => {
        (async () => {
            try {
                const res = await fetch(postsUrl);
                const posts: Post[] = await res.json();
                await setPosts(posts);
            } catch(error) {
                setError(error)
            }
            setLoading(false)
        })();
    }, [])
}
```

Cool, pretty straight forward fetch on mount set up. One way we can handle CRUD is by simply passing `setPosts` to the children components:

```jsx
//App.tsx
return (
    <PostList posts={posts} />
    <SinglePost setPosts={setPosts} />
    <CreatePost setPosts={setPosts} />
)
```

And in, `CreatePost` for example, when a post is created, we can add it to our `posts` state:

```javascript
import React, { useState, Dispatch, SetStateAction } from 'react';
import { Post } from './App';

interface Props {
    setPosts: Dispatch<SetStateAction<Post[]>>
}

//Use TS Omit utility to omit id property that will be generated by the server
type CreatePostRequest = <Omit<Post, 'id'>>

const initialFormState: CreatePostRequest = { content: '', date: new Date() }

const CreatePost: React.FC<Props> = ({ setPosts }): JSX.Element => {
    const [newPost, setNewPost] = useState<Omit<Post, 'id'>>(initialFormState);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<boolean>(false);

    const createPost = async (): Promise<void> => {
        setLoading(true);
        try {
            const res = await fetch(createPostUrl, {
                method: 'POST',
                body: JSON.stringify(newPost)
            })
            const createdPost: Post = await res.json();
            //update parent state
            setPosts(prevPosts => [...prevPosts, createdPost]);
            setNewPost(initialFormState)
        } catch(error) {
            setError(error)
        }
        setLoading(false)
    }

    ...

    <form onSubmit={createPost}>
        ...
    </form>
}
```

So when the form is submitted, fire a request to create the post, which returns the created post. We can then add that posts to our parent `App`'s local state. As a reminder, the initial argument to any set state function is the previous state, so we can just tack our new posts onto the previous posts.

Even though passing the the state updater defined in `App` works, it's a poor paradigm. There's a burden placed on consuming components by the fact that they have to know to use the initial previous state argument. Not only this, but `App` is essentially allowing any component consuming its state updater to do whatever it wants with the state.

Conceptually, I like to think of any component that houses a given piece of state as server, of sorts, for that state. By that I mean, it is that state's single source of truth, and for all intents and purposes is an API for other parts of your app.

## Type safe state setters

Let's define some CRUD operators that we can pass around with a bit more confidence.

```jsx
//App.tsx
const addPostToLocalState = (newPost: Post) => {
    setPosts(prevPosts => [...prevPosts, newPost])
}

const updatePostInLocalState = (updatedPost: Post) => {
    setPosts(prevPosts => prevPosts.map(post => post.id === updatedPost.id ? updatedPost : post))
}

const deletePostFromLocalState = (postId: string) => {
    setPosts(prevPosts => prevPosts.filter(({ id }) => id !== postId))
}
```

So now when we pass these to the children components, you should notice some key differences, first of which is the fact that consumers don't have to have any knowledge of state, they just pass the required argument to the operation and it's taken care of. Also, I like to be verbose and descriptive when naming local state updaters to not confuse yourself or other developers. This is particularly imperative when working in a codebase that is dispatching Redux actions for certain functionality/pieces of state.

That's about it!

Thanks for listening üëãüèª